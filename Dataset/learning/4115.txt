/* Generated By:JJTree: Do not edit this line. AstFunNode.java */
package com.developmentontheedge.sql.model;

import one.util.streamex.StreamEx;

import java.util.Arrays;
import java.util.function.Predicate;


/**
 * Any function or operator.
 *
 * @pending - refine priorities.
 */
public class AstFunNode extends SimpleNode
{
    /////////////////////////////////////////////////////////////////
    // Function and operators priorities
    //
    // pending: refine
    public static final int LOGICAL_PRIORITY = 1; // and, or, xor
    public static final int RELATIONAL_PRIORITY = 2; // eq, neq, gt, lt, geq, leq
    public static final int PLUS_PRIORITY = 3; // plus, minus
    public static final int TIMES_PRIORITY = 4; // times, divide
    public static final int UNARY_PRIORITY = 5; // not, unary minus
    public static final int POWER_PRIORITY= 6; // power
    public static final int FUNCTION_PRIORITY = 7; // misc: sqrt, sin, cos, ...

    public AstFunNode(int id)
    {
        super(id);
    }

    public AstFunNode(Function fn)
    {
        this(SqlParserTreeConstants.JJTFUNNODE);
        setFunction(fn);
    }

    /////////////////////////////////////////////////////////////////
    // Properties
    //

    // to preserve formatting
    private Token operator;

    public Token getOperator()
    {
        return operator;
    }

    public void setOperator(Token operator)
    {
        this.operator = operator;
    }

    private Function function;

    public Function getFunction()
    {
        return function;
    }

    /**
     * Sets the function for a node.
     * It is parser responsibility to check the function validness.
     */
    public void setFunction(Function function)
    {
        this.function = function;
        updateContent();
    }

    private void updateContent()
    {
        if (function.getPriority() == Function.FUNCTION_PRIORITY || function.getPriority() == Function.AGGREGATE_FUNCTION_PRIORITY)
        {
            this.nodePrefix = function.getName() + "(";
            this.childrenDelimiter = ",";
            this.nodeSuffix = ")";
        }
        else
        {
            this.nodePrefix = null;
            this.nodeSuffix = null;
            this.childrenDelimiter = function.getName().equals("u-") ? "-" : function.getName();
        }
    }

    private boolean distinct;

    public void setDistinct(boolean distinct)
    {
        if (distinct)
            this.nodePrefix += "DISTINCT";
        this.distinct = distinct;
    }

    public boolean isDistinct()
    {
        return distinct;
    }

    @Override
    public String getChildrenDelimiter(SimpleNode prev, SimpleNode next)
    {
        return next instanceof AstOrderBy ? null : "group_concat".equalsIgnoreCase(function.getName()) ? "SEPARATOR" : childrenDelimiter;
    }

    @Override
    public String getNodePrefix()
    {
        return nodePrefix == null && jjtGetNumChildren() == 1 && function.minNumberOfParams() == 1 && function.maxNumberOfParams() == 1
                ? childrenDelimiter : nodePrefix;
    }

    /**
     * Returns a string containing the function name.
     */
    @Override
    public String toString()
    {
        return function == null ? "Unknown function" : "Function \"" + function.getName() + "\"";
    }

    @SafeVarargs
    public static Predicate<SimpleNode> isFunction(String fnName, Predicate<SimpleNode>... childConditions)
    {
        return isFunction(fnName).and(node -> childConditions.length == node.jjtGetNumChildren()
                && !StreamEx.zip(Arrays.asList(childConditions), node.children, Predicate::test).has(false));
    }

    private boolean withinDbmsTransform;

    public void setWithinDbmsTransform(boolean within)
    {
        this.withinDbmsTransform = within;
    }

    public boolean withinDbmsTransform()
    {
        return withinDbmsTransform;
    }

    public static Predicate<SimpleNode> isFunction(String fnName)
    {
        return node -> node instanceof AstFunNode && ((AstFunNode) node).getFunction().getName().equalsIgnoreCase(fnName);
    }
}
